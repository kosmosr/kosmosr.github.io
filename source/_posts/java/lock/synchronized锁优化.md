---
title: Synchronized锁优化
date: 2020/8/17 10:20:00
categories:
- JAVA
- 锁
---
## Synchronized锁优化

Synchronized在JDK6之前，实现比较简单粗暴，由此带来了效率低下的问题，而在JDK6及其之后的版本，对其进行了优化

## 优先前

Synchronized在JDK6之前，通过对象内部的Monitor来实现线程同步，而Monitor又依赖于底层操作系统的**Mutex Lock（互斥锁）**来实现的线程同步；

而操作系统实现线程间的切换需要从用户态转换到内核态，这个转换需要相对比较长的时间，即使你的代码块非常简单，导致状态转换消耗的时间可能比代码执行的时间还要长，这就是JDK6之前synchronized效率低的原因，这种实现方式，我们称之为**重量级锁**

## 优化后

在JDK6及其之后版本中，加入了**偏向锁**和**轻量级锁**，且锁级别由低到高分别是是：无锁、偏向锁、轻量级锁、重量级锁

且锁的等级只可以升级，不能降级（其实HotSpot支持锁降级，但是条件比较苛刻，基本认为不能降级）

> 参考HotSpot锁的降级：https://segmentfault.com/q/1010000020803904/a-1020000020811620

### 偏向锁
JDK中默认开启偏向锁，由JVM参数：`-XX:+UseBiasedLocking`控制

HotSpot作者经过研究实践发现，**在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得**，为了让线程获得锁的代价更低，引进了偏向锁

#### 优势
为了在没有多线程竞争的情况下尽量**减少不必要的轻量级锁执行路径**；因为轻量级锁的加锁解锁操作是需要依赖**多次CAS**原子指令的，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令

适合无竞争的场景，理想的情况为总是由同一个线程去访问同步块、获取某个对象的锁

### 轻量级锁
进入条件

- 当偏向锁关闭时
- 当多个线程竞争偏向锁

#### 优势
在没用多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量时产生的性能消耗
当线程竞争锁失败时，不断通过**自旋**获取锁，当自旋达到一定次数时，放弃自旋膨胀成为重量级锁
适用于少量线程交替获取锁

### 重量级锁
通过对象内部的Monitor实现，此时对象头的Mark word指向对象ObjectMonitor对象指针，需要进行状态切换从用户态转到内核态，该锁级别下使用成本比较高

## 总结

| 锁       | 优点                                                         | 缺点                                         | 适用场景                       |
| -------- | ------------------------------------------------------------ | -------------------------------------------- | ------------------------------ |
| 偏向锁   | 加锁与解锁不需要额外消耗，和执行非同步方法仅存在纳秒级的差距 | 如果线程间存在锁竞争，会带来额外的锁撤销消耗 | 只有一个线程访问同步块场景     |
| 轻量级锁 | 竞争的线程不会阻塞                                           | 没有得到锁的线程需要一直自旋，消耗CPU        | 追求响应时间，少量线程交替执行 |
| 重量级锁 | 线程竞争不使用自旋，不消耗CPU                                | 线程阻塞，状态切换成本高，响应时间缓慢       | 追求吞吐量，同步块执行速度较长 |



## 参考资料

> [啃碎并发（七）：深入分析Synchronized原理](https://juejin.im/post/6844903640197513230)
> [不可不说的Java“锁”事](https://tech.meituan.com/2018/11/15/java-lock.html)
> [JAVA并发笔记之synchronized 偏向锁 轻量级锁 重量级锁证明](https://blog.csdn.net/weixin_36586564/article/details/103633113)
